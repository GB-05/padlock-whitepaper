\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{glossaries}

\geometry{ margin=1in }

\makeglossaries

\newglossaryentry{ASIC}
{
    name=ASIC,
    description={Application Specific Integrated Circuit. Often used to mine
    cryptocurrencies, the most prominent being bitcoin}
}

\newglossaryentry{segwit}
{
    name=Segwit,
    description={Freeing block size limit by segragating signature (witness)
    data}
}

\newglossaryentry{mempool}
{
    name=Mempool,
    description={Pool of all entries that want to be included in a block}
}

\title{
    PADLOCK \\
    \large Protocol Allowing for Decentralized Locking/Ownership of C-hashes to
    K-public keys
}
\author{Ellis Frank}

\begin{document}

\maketitle

\begin{abstract}
    PADLOCK is a blockchain based protocol that allows for the
    creation of a scalable and private cryptocurrency. It achieves this by only
    storing a hash of the input and the output, only a hash of the signature, and
    then a 8 byte anti-spam proof of work. These are the only details that need to
    be publicly disclosed on the blockchain in order for a transaction recipient to
    be able to verify that the coins they have received were not double spent. This
    results in an incredibly small transaction size of only 72 bytes, allowing for
    around 4x more throughput than bitcoin.
\end{abstract}

\section{Introduction}
PADLOCK is a blockchain based system that allows the
ownership and transfer of hashes by key pairs. The purpose of this hash
ownership is to provide the base for creating a scalable and private currency
that runs on top of the PADLOCK blockchain. This paper assumes a general
understanding of how traditional cryptocurrencies work.

\section{How Does PADLOCK Work?}
PADLOCK uses digital signatures to facilitate the ownership of hashes. However,
it does it differently to how most systems work. Only a hash of the signature is
stored on-chain, and the public key is left off-chain. Alongside the signature
hash is an input hash, an output hash, and a proof of work. These four together,
make up an \textit{entry}.

\begin{verbatim}

\\ Example written in Rust

type Hash = [u8; 16];

struct Entry {
    input: Hash,
    output: Hash,
    signature_hash: Hash,
}

\end{verbatim}

Anyone can submit any entry to the blockchain. They do not have to provide any
sort of signature, just an object of three 16 byte arrays. This provides a base
for creating a scalable, private, and non-double-spendable cryptocurrency.

\section{Creating Coins on PADLOCK}

\subsection{What is a Coin}
It's important to make a distinction when talking about coins in this context.
Coins, in this context, do not refer to a unit of currency, but rather a chain
of digital signatures. When you transfer a coin, you are appending a signature
to this history. Each transaction has an \textit{input} and \textit{output}. The
input is the hash of the transaction's sender, and the output of the
recipient(s) of the coin. The input is represented as the hash of the previous
transaction.

\begin{verbatim}

\\ Example written in Rust
struct Coin {
    transactions: Vec<Transaction>,
}

struct Transaction {
    input_hash: Hash,
    output: Vec<PublicKey>,
    hash: Hash,
    signature: [u8; 64],
}

\end{verbatim}

This coin can be split into multiple coins as well, specifying more than one
public key as the new owner, each representing a fraction of the value of the
original coin. If a sender sends their coin to someone, they can send a
fraction of it to the receiver, and then the rest back to themselves, as change.

The \textit{coinfile} is a file that contains the history of a coin, back to
it's minting.

\subsection{The Double Spend Problem}
These coins, on their own, do not work as a currency. The receiver of a coin
does not know whether the sender has already spent that coin. If Alice has a
coin, she can create a transaction giving ownership to Bob on her coinfile, and
send that to Bob, then use the same coin to send one to Tom, and unless Tom and
Bob know each other, there is no way for either of them to know Alice has spent
the coin twice.

\subsubsection{How it has been traditionally solved}
Traditional cryptocurrencies solve this problem by having every coins history be
disclosed publicly on a blockchain. Transactions are only allowed on the
blockchain, if the sender has not already spent the output that is being used as
the input.

\subsubsection{The Issue With This Solution}
The issue, is that hosting a full node can start to take a lot of disk space,
and bandwidth. At the time of writing this, the bitcoin blockchain is 310
gigabytes. It grows at approximately 200 megabytes per day when at around max
capacity. The block size is capped out at around 1.3-1.6 megabytes (although
it's variable due to \gls{segwit}) in order to prevent the blockchain from getting too
big, too quick.  This causes for a bottleneck to occur, where there are more
transactions wanting to confirm than can fit in too the next block, or even the
next 5, 10, or at the time of writing this, 40 blocks. Because transaction fees
are a market based system, due to supply and demand, the fees spike. At the time
of writing this, a low priority transaction takes approximately 4.5 USD, and in
order to be in the next block, you must pay around 7.5 USD in fees.

One solution that has been tried is merely increasing the block size limit.
This means more transaction can be included in the next block, getting rid of
the bottleneck. This however, leads to centralization issues. Due to the
increasing storage and bandwidth requirements, hosting a full node will become
infeasible for most people, and will only be done by a few.

A better solution is to include as many transactions as possible in the limited
amount of space each block has. In order to do that, you have to decrease the
amount of storage each transaction takes up. Under PADLOCK, each transaction
takes only 56 bytes minimum, compared to the ~190 byte minimum on bitcoin
(including witness data). This results in nearly 3x more throughput when using
the PADLOCK system.

\subsection{How PADLOCK Solves the Double Spend Problem}
PADLOCK solves it by having each transaction of a coin have it's input, output,
and signature each hashed, and then used as an entry on the PADLOCK blockchain.
At a basic level, one can verify whether a coin has already been spent by
hashing the input of the transaction sent to them, and then seeing if that input
has been used on any entries in the blockchain. If it has, you would know that
the coin has already been spent. Each entry would contain a public key, and a
signature in order to verify the ownership of each hash.

There are two optimizations that will be done to reduce transaction size
further.  The first optimization is BLS Signature Aggregation. Every signature
in the block can be combined into one single 96 byte signature. This would
reduce a single input, single output transaction to 64 bytes (48 byte public
key, 8 byte input hash, 8 byte output hash, and 8 byte proof of work [see
section 6]). The other optimization is to keep an array of all public keys used,
and then transactions can use an index to this array to refer to their public
key, making a single-input single-output transaction 24 bytes (8 byte index, 8
byte input hash, 8 byte output hash, 8 byte proof of work).

\subsection{Issuance}
Issuance can be done via the 256 byte miner address field in the block header.
Miners can feel free to include whatever they please in this field. Generally,
though they'd want to include some sort of address. A coin could then allow
using the miner address as an input to a transaction.

\section{ASIC Resistance}
The proof of work algorithm used by PADLOCK should be \Gls{ASIC} resistant.
\Gls{ASIC} resistance is desirable because \Gls{ASIC} mining greatly increases
the barrier to entry for mining, making it inaccessible for most people, thus
centralizing mining.

Furthurmore, the algorithm chosen, RandomX, is also resistant to GPU mining, as
it is most efficiently mined on a CPU. The reason for this is to even further
lower the barrier to entry of mining. Anyone with a computer can mine when they
aren't using it, and don't need to have an expensive GPU. Although more research
needs to be done on this front, CPUs are known to typically have less power
consumption than GPUs and ASICs. This could result in less electricity being
needed to reach a safe level of security against 51 attacks, making PADLOCK have
the potential to be more environmentally friendly than cryptocurrencies that
rely on ASIC or GPU mining.

\section{Privacy}
Privacy is achieved first by pseudonymity. Transactions are associated with
someone's public key, rather than their real name. Of course, the issue there is
that if someone managed to trace a public key back to a real person, that
persons transactions would be publicly known.

A common way to combat that is by sending the change of each transaction to a
new public key. For example, say Alice sends 20 coins to Bob, from her public
key, A. A has 30 coins belonging to it. When she sends the transaction to Bob,
instead of sending the remaining 10 coins back to public key A, she makes a new
public key B, and sends the 10 coins to that. To an outsider, they are unable
to tell which public key was Alice's, and which was Bob's.

PADLOCK further combats this by not having every transaction publicly
available. Instead, they are all in each coinfile. Someone who possess a
coinfile would be able to see many transactions, but it would be incredibly
hard to piece together the entire history of all the transactions. This
drastically increases the privacy.

\section{Anti-Spam Measures}
It would be possible to execute a denial of service attack on PADLOCK by simply
filling the \gls{mempool} with meaningless entries. It would then make it
increasingly unlikely that the legitimate entries would be added to a block.
Most cryptocurrencies use a transaction fee, which makes it very uneconomical
for an attacker to create enough transactions to fill the \gls{mempool}.
Transaction fees are infeasible to implement under PADLOCK however. It would
involve sending many gigabytes (possibly in the hundreds) worth of coinfiles to
the miner, which would take up immense bandwidth and storage.

Instead, on PADLOCK each transaction must submit a proof of work. The proof of
work algorithm for this will be very similar to hashcash. You must make an md5
hash of the entry with a nonce. The first N bits of the hash must be zeros.
This nonce can be up to 8 bytes, and is then stored with the entry. All of the
work included in a block would then reduce the amount of work the miner has to
do.

\[ TotalWork = SumEntryWork + MinerWork \]

This makes it so that miners have an incentive to include the entries with the
most work in their blocks, so they don't have to do as much work to mine a
block. The SumEntryWork will only be able to make up 10\% of the total work in a
block.

Instead of being economically expensive to execute a DOS attack, PADLOCK makes
it very computationally expensive.

\section{Conclusion}
PADLOCK is a blockchain system designed to allow for a high throughput, and
privacy. All the blockchain does is allow for checking if a coin has already
been spent. This is the minimum for a functioning digital currency. Because of
this, transactions take very little disk space, allowing a very high throughput.
\Gls{ASIC} resistance is achieved through algorithm switching.  Due to
transactions not being publicly disclosed on chain, it achieves a high level of
privacy. DOS attacks can be countered by requiring proof of work to be submitted
with each transaction. All this together creates a very robust base for a
digital currency.

\printglossaries

\end{document}
