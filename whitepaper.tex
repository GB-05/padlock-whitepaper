\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{glossaries}

\geometry{ margin=1in }

\makeglossaries

\newglossaryentry{ASIC}
{
    name=ASIC,
    description={Application Specific Integrated Circuit. Often used to mine
    cryptocurrencies, the most prominent being bitcoin}
}

\newglossaryentry{segwit}
{
    name=Segwit,
    description={Freeing block size limit by segragating signature (witness)
    data}
}

\newglossaryentry{mempool}
{
    name=Mempool,
    description={Pool of all entries that want to be included in a block}
}

\title{
    PADLOCK \\
    \large Protocol Allowing for Decentralized Locking/Ownership of C-hashes to
    K-public keys
}
\author{Ellis Frank}

\begin{document}

\maketitle

\begin{abstract}
    PADLOCK is a blockchain based protocol that allows for the
    creation of a scalable and private cryptocurrency. It achieves this by only
    storing a hash of the input and the output, only a hash of the signature, and
    then an 8 byte anti-spam proof of work. These are the only details that need to
    be publicly disclosed on the blockchain in order for a transaction recipient to
    be able to verify that the coins they have received were not double spent. This
    results in an incredibly small transaction size of only 68 bytes, allowing for
    nearly 3x more throughput than bitcoin when using a similar block size.
\end{abstract}

\section{Introduction}
PADLOCK is a blockchain based system that allows the
ownership and transfer of hashes by key pairs. The purpose of this hash
ownership is to provide the base for creating a scalable and private currency
that runs on top of the PADLOCK blockchain. This paper assumes a general
understanding of how traditional cryptocurrencies work.

\section{How Does PADLOCK Work?}
PADLOCK uses digital signatures to facilitate the ownership of hashes. Each
"transaction" consists of an array of input hashes. The output is only one hash.
There is then a public key and signature to go along with this. Together, these
form an \textit{entry}.

There are two optimizations that will be done to reduce transaction size
further. The first optimization is BLS Signature Aggregation. Every signature in
the block can be combined into one single 96 byte signature. This would reduce a
single input, single output transaction to 72 bytes (48 byte public key, 8 byte
input hash, 8 byte output hash, 8 byte proof of work [see section 6]). The other
optimization is to use indexes to public keys and input hashes. There will be an
array of all public keys used. Rather than using the entire public key in an
entry, you can instead use an index to this array. The same goes for inputs.
Each public key will have an associated array of input hashes, listed in
chronological order. In the entry, you can use a 32 bit integer to refer to
them, taking only 4 bytes instead of 8.

\begin{verbatim}

\\ Example written in Rust

type Hash = [u8; 8];
type PublicKey = [u8; 48]

struct Entry {
    input_indexes: Vec<u32>,
    output: Hash,
    public_key: Option<BlsPublicKey>,
    public_key_index: Option<u64>,
}

\end{verbatim}


This provides a base for creating a scalable, private, and non-double-spendable
cryptocurrency.

\section{Creating Coins on PADLOCK}

\subsection{What is a Coin}
It's important to make a distinction when talking about coins in this context.
Coins, in this context, do not refer to a unit of currency, but rather a chain
of digital signatures. When you transfer a coin, you are appending a signature
to this history. Each transaction has an \textit{input} and \textit{output}. The
input is the hash of the transaction's sender, and the output is of the
recipient(s) of the coin. The input is represented as the hash of the previous
transaction.

\begin{verbatim}

\\ Example written in Rust
struct Coin {
    transactions: Vec<Transaction>,
}

struct Transaction {
    input_hash: Hash,
    output: Vec<PublicKey>,
    hash: Hash,
    signature: [u8; 64],
}

\end{verbatim}

This coin can be split into multiple coins as well, specifying more than one
public key as the new owner, each representing a fraction of the value of the
original coin. If a sender sends their coin to someone, they can send a
fraction of it to the receiver, and then the rest back to themselves as change.

The \textit{coinfile} is a file that contains the history of a coin, back to
it's minting.

\subsection{The Double Spend Problem}
These coins, on their own, do not work as a currency. The receiver of a coin
does not know whether the sender has already spent that coin. If Alice has a
coin, she can create a transaction giving ownership to Bob on her coinfile, and
send that to Bob, then use the same coin to send one to Tom, and unless Tom and
Bob know each other, there is no way for either of them to know Alice has spent
the coin twice.

\subsubsection{Traditional Solutions}
Traditional cryptocurrencies solve this problem by having every coins history be
disclosed publicly on a blockchain. Transactions are only allowed on the
blockchain, if the sender has not already spent the output that is being used as
the input.

\subsubsection{The Issue With This Solution}
The issue, is that hosting a full node can take a lot of disk space,
and bandwidth. At the time of writing this, the bitcoin blockchain is 310
gigabytes. It grows at around 200 megabytes per day when operating at max
capacity. The block size is capped out at around 1.3-1.6 megabytes (although
it varies due to \gls{segwit}) in order to prevent the blockchain from getting too
big, too quick.  This can cause a bottleneck to occur, where there are more
transactions wanting to confirm than can fit in too the next block, or even the
next 5, 10, or at the time of writing this, 40 blocks. Because transaction fees
are a market based system, due to supply and demand, the fees spike. At the time
of writing this, a low priority transaction takes approximately 4.5 USD, and in
order to be in the next block, you must pay around 7.5 USD in fees.

One solution that has been tried is merely increasing the block size limit.
This means more transaction can be included in the next block, getting rid of
the bottleneck. This however, leads to centralization issues. Due to the
increasing storage and bandwidth requirements, hosting a full node will become
infeasible for most people, and will only be done by a few.

A better solution is to include as many transactions as possible in the limited
amount of space each block has. In order to do that, you have to decrease the
amount of storage each transaction takes up. Under PADLOCK, each transaction
takes only 64 bytes minimum, compared to the ~190 byte minimum on bitcoin
(including witness data). This results in nearly 3x more throughput when using
the PADLOCK blockchain.

\subsection{How PADLOCK Solves the Double Spend Problem}
PADLOCK solves it by having each transaction of a coin have it's input, output,
and signature each hashed, and then used as an entry on the PADLOCK blockchain.
At a basic level, one can verify whether a coin has already been spent by
hashing the input of the transaction sent to them, and then seeing if that input
has been used on any entries in the blockchain. If it has, you would know that
the coin has already been spent.

There are two optimizations that will be done to reduce transaction size
further.  The first optimization is BLS Signature Aggregation. Every signature
in the block can be combined into one single 96 byte signature. This would
reduce a single input, single output transaction to 64 bytes (48 byte public
key, 8 byte input hash, 8 byte output hash, and 8 byte proof of work [see
section 6]). The other optimization is to keep an array of all public keys used,
and then transactions can use an index to this array to refer to their public
key, making a single-input single-output transaction 24 bytes (8 byte index, 8
byte input hash, 8 byte output hash, 8 byte proof of work).

\subsection{Issuance}
Issuance can be done via the 128 byte miner address field in the block header.
Miners can feel free to include whatever they please in this field. Generally,
though they'd want to include some sort of address. A coin could then allow
using this as an input to a transaction.

\section{ASIC Resistance}
The proof of work algorithm used by PADLOCK should be \Gls{ASIC} resistant.
\Gls{ASIC} resistance is desirable because \Gls{ASIC} mining greatly increases
the barrier to entry for mining, making it inaccessible for most people, thus
centralizing mining.

Furthurmore, the algorithm chosen, RandomX, is also resistant to GPU mining, as
it is most efficiently mined on a CPU. The reason for this is to even further
lower the barrier to entry of mining. Anyone with a computer can mine when they
aren't using it, and don't need to have an expensive GPU. Although more research
needs to be done on this front, CPUs are known to typically have less power
consumption than GPUs and ASICs. This could result in less electricity being
needed to reach a safe level of security against 51 attacks, making PADLOCK have
the potential to be more environmentally friendly than cryptocurrencies that
rely on ASIC or GPU mining.

\section{Privacy}
Privacy is achieved first by pseudonymity. Transactions are associated with
someone's public key, rather than their real name. Of course, the issue there is
that if someone managed to trace a public key back to a real person, that
persons transactions would be publicly known.

A common way to combat that is by sending the change of each transaction to a
new public key. For example, say Alice sends 20 coins to Bob, from her public
key, A. A has 30 coins belonging to it. When she sends the transaction to Bob,
instead of sending the remaining 10 coins back to public key A, she makes a new
public key B, and sends the 10 coins to that. To an outsider, they are unable
to tell which public key was Alice's, and which was Bob's.

PADLOCK further combats this by not having every transaction publicly
available. Instead, they are all in each coinfile. Someone who possess a
coinfile would be able to see many transactions, but it would be incredibly
hard to piece together the entire history of all the transactions. This
drastically increases the privacy.

However, this still has some pitfalls, as someone who recieves a transaction,
and knows the sender, would be able to link their identity to their address, and
would be able to see what address they sent their change to. This data could
cause fungibility of that coin to be ruined if the person behind the address was
deemed as undesirable


\section{Anti-Spam Measures}
It would be possible to execute a denial of service attack on PADLOCK by simply
filling the \gls{mempool} with meaningless entries. It would then make it
increasingly unlikely that the legitimate entries would be added to a block.
Most cryptocurrencies use a transaction fee, which makes it very uneconomical
for an attacker to create enough transactions to fill the \gls{mempool}.
Transaction fees are infeasible to implement under PADLOCK, however. It would
involve sending many gigabytes (possibly in the hundreds) worth of coinfiles to
the miner, which would take up immense amounts of bandwidth and storage.

Instead, on PADLOCK each transaction must submit a proof of work. The proof of
work algorithm for this will be very similar to Hashcash. You must make an md5
hash of the entry with a nonce. The first N bits of the hash must be zeros.
This nonce can be up to 8 bytes, and is then stored with the entry. All of the
work included in a block would then reduce the amount of work the miner has to
do.

\[ TotalWork = SumEntryWork + MinerWork \]

This makes it so that miners have an incentive to include the entries with the
most work in their blocks, so they don't have to do as much work to mine a
block. 

Instead of being economically expensive to execute a DOS attack, PADLOCK makes
it very computationally expensive.

\section{Conclusion}
PADLOCK is a blockchain system designed to allow for a high throughput, and
privacy. All the blockchain does is allow for checking if a coin has already
been spent. This is the minimum for a functioning digital currency. Because of
this, transactions take very little disk space, allowing a very high throughput.
\Gls{ASIC} resistance is achieved through algorithm switching.  Due to
transactions not being publicly disclosed on chain, it achieves a high level of
privacy. DOS attacks can be countered by requiring proof of work to be submitted
with each transaction. All this together creates a very robust base for a
digital currency.

\printglossaries

\end{document}
